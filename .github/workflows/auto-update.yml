name: auto-update

on:
  schedule:
    - cron: "19 3 * * *"
  workflow_dispatch:

permissions:
  contents: write
  actions: write

concurrency:
  group: auto-update
  cancel-in-progress: false

jobs:
  update:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Resolve upstream versions
        id: versions
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          python - <<'PY'
          from __future__ import annotations

          import json
          import os
          import sys
          import urllib.error
          import urllib.request

          token = os.environ.get("GH_TOKEN", "")

          def fetch_json(url: str, use_token: bool) -> object:
              headers = {"Accept": "application/vnd.github+json"}
              if use_token and token:
                  headers["Authorization"] = f"Bearer {token}"
              req = urllib.request.Request(url, headers=headers)
              with urllib.request.urlopen(req, timeout=20) as resp:
                  return json.load(resp)

          def get_json(url: str) -> object:
              try:
                  return fetch_json(url, True)
              except urllib.error.HTTPError as exc:
                  if token:
                      try:
                          return fetch_json(url, False)
                      except urllib.error.HTTPError:
                          raise exc
                  raise

          def latest_release_tag(repo: str) -> str | None:
              url = f"https://api.github.com/repos/{repo}/releases/latest"
              try:
                  data = get_json(url)
              except urllib.error.HTTPError as exc:
                  if exc.code != 404:
                      raise
                  return None
              tag = data.get("tag_name") if isinstance(data, dict) else None
              return tag if tag and tag != "null" else None

          def latest_tag(repo: str) -> str:
              url = f"https://api.github.com/repos/{repo}/tags?per_page=1"
              data = get_json(url)
              if not isinstance(data, list) or not data:
                  raise RuntimeError(f"No tags found for {repo}")
              name = data[0].get("name")
              if not name:
                  raise RuntimeError(f"Tag name missing for {repo}")
              return name

          def latest_commit_sha(repo: str) -> str:
              url = f"https://api.github.com/repos/{repo}/commits?per_page=1"
              data = get_json(url)
              if not isinstance(data, list) or not data:
                  raise RuntimeError(f"No commits found for {repo}")
              sha = data[0].get("sha")
              if not sha:
                  raise RuntimeError(f"Commit sha missing for {repo}")
              return sha

          def resolve_release_or_tag(repo: str) -> str:
              tag = latest_release_tag(repo)
              return tag or latest_tag(repo)

          try:
              caddy_version = resolve_release_or_tag("caddyserver/caddy")
              cloudflare_version = resolve_release_or_tag("caddy-dns/cloudflare")
              l4_version = latest_release_tag("mholt/caddy-l4") or latest_commit_sha("mholt/caddy-l4")
          except Exception as exc:
              print(f"Failed to resolve upstream versions: {exc}", file=sys.stderr)
              sys.exit(1)

          output_path = os.environ.get("GITHUB_OUTPUT")
          if not output_path:
              print("GITHUB_OUTPUT is not set", file=sys.stderr)
              sys.exit(1)

          with open(output_path, "a", encoding="utf-8") as f:
              f.write(f"caddy={caddy_version}\n")
              f.write(f"cloudflare={cloudflare_version}\n")
              f.write(f"l4={l4_version}\n")
          PY

      - name: Update Dockerfile and README
        id: update
        env:
          CADDY_VERSION: ${{ steps.versions.outputs.caddy }}
          L4_VERSION: ${{ steps.versions.outputs.l4 }}
          CLOUDFLARE_VERSION: ${{ steps.versions.outputs.cloudflare }}
        run: |
          set -euo pipefail
          python - <<'PY'
          from __future__ import annotations

          import os
          import re
          from pathlib import Path

          caddy = os.environ["CADDY_VERSION"]
          l4 = os.environ["L4_VERSION"]
          cloudflare = os.environ["CLOUDFLARE_VERSION"]

          def update_file(path: str, rules: list[tuple[str, str]]) -> None:
              p = Path(path)
              text = p.read_text()
              updated = text
              for pattern, repl in rules:
                  updated, count = re.subn(pattern, repl, updated, flags=re.M)
                  if count == 0:
                      raise SystemExit(f"Pattern not found in {path}: {pattern}")
              if updated != text:
                  p.write_text(updated)

          update_file(
              "Dockerfile",
              [
                  (r"^ARG CADDY_VERSION=.*$", f"ARG CADDY_VERSION={caddy}"),
                  (r"^ARG L4_COMMIT=.*$", f"ARG L4_COMMIT={l4}"),
                  (r"^ARG CLOUDFLARE_VERSION=.*$", f"ARG CLOUDFLARE_VERSION={cloudflare}"),
              ],
          )

          update_file(
              "README.md",
              [
                  (r"^- Caddy: `.*`$", f"- Caddy: `{caddy}`"),
                  (r"^- caddy-l4: `.*`$", f"- caddy-l4: `{l4}`"),
                  (r"^- caddy-dns/cloudflare: `.*`$", f"- caddy-dns/cloudflare: `{cloudflare}`"),
              ],
          )
          PY

          if git diff --quiet; then
            echo "changed=false" >> "$GITHUB_OUTPUT"
          else
            echo "changed=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Commit, tag, and release
        if: steps.update.outputs.changed == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          CADDY_VERSION: ${{ steps.versions.outputs.caddy }}
          L4_VERSION: ${{ steps.versions.outputs.l4 }}
          CLOUDFLARE_VERSION: ${{ steps.versions.outputs.cloudflare }}
        run: |
          set -euo pipefail
          git fetch --tags

          caddy_version="${CADDY_VERSION#v}"
          IFS=. read -r caddy_major caddy_minor _ <<<"$caddy_version"
          series_regex="^v${caddy_major}\\.${caddy_minor}\\.[0-9]+$"
          latest_tag=$(git tag -l "v${caddy_major}.${caddy_minor}.*" | grep -E "$series_regex" | sort -V | tail -n1 || true)

          if [ -z "$latest_tag" ]; then
            next="v${caddy_major}.${caddy_minor}.0"
          else
            version="${latest_tag#v}"
            IFS=. read -r _ _ patch <<<"$version"
            patch=$((patch + 1))
            next="v${caddy_major}.${caddy_minor}.${patch}"
          fi

          git add Dockerfile README.md
          git commit -m "chore: bump upstream versions"
          git push origin HEAD

          git tag "$next"
          git push origin "$next"

          gh release create "$next" \
            --title "$next" \
            --notes "Automated update: Caddy ${CADDY_VERSION}, caddy-l4 ${L4_VERSION}, caddy-dns/cloudflare ${CLOUDFLARE_VERSION}"

          gh workflow run build-and-push -r "$next"
